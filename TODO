PLAN MAESTRO “TIRECODE” — CHECKLIST POR ORDEN (de 0 a producción)

Aterrizaje del MVP (antes de escribir código)
<!-- [ ] Nombre del proyecto y repo definidos (ej. tirecode) listo -->
<!-- [ ] Regla 1:1 confirmada: medida base ↔ código público listo -->
<!-- [ ] Decisión de formato de medida base: “205/55R16” (sin espacios) listo -->
<!-- [ ] Decisión: LI/SI (carga/velocidad) opcional (ej. 91V) listo -->
<!-- [ ] Definir ejemplos reales (5–10) para tests y seed: listo -->
<!-- [ ] “205/55R16” → “100” listo -->
<!-- [ ] “195/65R15” → “101” listo -->
<!-- [ ] “215/60R16” → “102” listo -->
<!-- [ ] “225/45R17” → “103” listo -->
<!-- [ ] “235/50R18” → “104” listo -->
<!-- [ ] “245/40R18” → “105” listo -->
<!-- [ ] “255/55R19” → “106” listo -->
<!-- [ ] “265/70R17” → “107” listo -->
<!-- [ ] “205/55R16 91V” (variant) → “100 91V” (SI es una letra) listo -->
<!-- [ ] “225/45R17 94W” (variant) → “103 94W” (SI es una letra) listo -->
<!-- [ ] Contrato de búsqueda: listo -->
<!-- [ ] Input: “100” → salida: “205/55R16” listo -->
<!-- [ ] Contrato de búsqueda: listo -->
<!-- [ ] Input: “100” → salida: “205/55R16” listo -->
<!-- [ ] Input: “205/55R16” → salida: “100” listo -->
<!-- [ ] Input: “100 91V” o “205/55R16 91V” → salida: base + variant (si existe) listo -->

Setup profesional del repo (lo que te hace serio desde el día 1)
<!-- [ ] Crear repo Git + README (cómo correr dev en 5 líneas) listo -->
<!-- [ ] Inicializar backend NestJS (TypeScript strict) listo -->
<!-- [ ] ESLint + Prettier listo -->
<!-- [ ] Husky pre-commit: lint + test rápido (opcional, pero pro) listo -->
<!-- [ ] Config de env con validación (dev/stage/prod) listo -->
<!-- [ ] Dockerfile multi-stage para API listo -->
<!-- [ ] docker-compose dev: listo -->
<!-- [ ] api listo -->
<!-- [ ] postgres listo -->
<!-- [ ] redis listo -->
<!-- [ ] Scripts npm: listo -->
<!-- [ ] dev listo -->
<!-- [ ] lint listo -->
<!-- [ ] test listo -->
<!-- [ ] build listo -->
<!-- [ ] start:prod listo -->

Arquitectura y estructura (sin esto, en 1 mes es un spaghetti)
<!-- [ ] Crear módulos Nest (monolito modular): listo -->
<!-- [ ] catalog (core: medidas/códigos/variantes) listo -->
<!-- [ ] lookup (caso de uso de búsqueda) listo -->
<!-- [ ] admin (gestión) listo -->
<!-- [ ] observability (logging, health) listo -->
<!-- [ ] Definir capas (aunque sea simple): listo -->
<!-- [ ] controllers listo -->
<!-- [ ] services/use-cases listo -->
<!-- [ ] repositories (infra) listo -->
<!-- [ ] domain (reglas + normalización) listo -->
<!-- [ ] DTOs + validación en todos los endpoints listo -->
<!-- [ ] Error handling global (filter) con formato estándar: listo -->
<!-- [ ] { error: { code, message, details? }, requestId } listo -->
<!-- [ ] Request ID tracing con UUID por request listo -->
<!-- [ ] Structured logging (JSON format) listo -->
<!-- [ ] x-request-id header en todas las respuestas listo -->

Base de datos (PostgreSQL) — modelo final sin huecos
El modelo queda así (para ser escalable y limpio):

<!-- [ ] Tabla tire_sizes listo -->
<!-- [ ] id (uuid) listo -->
<!-- [ ] size_raw (texto tal como lo envían) listo -->
<!-- [ ] size_normalized (UNIQUE) ej "205/55R16" listo -->
<!-- [ ] width (int) 205 listo -->
<!-- [ ] aspect_ratio (int) 55 listo -->
<!-- [ ] rim_diameter (int) 16 listo -->
<!-- [ ] created_at / updated_at listo -->

<!-- [ ] Tabla tire_codes listo -->
<!-- [ ] id (uuid) listo -->
<!-- [ ] code_public (varchar) UNIQUE ← aquí guardas "100" listo -->
<!-- [ ] tire_size_id UNIQUE (FK) ← garantiza 1:1 listo -->
<!-- [ ] created_at / updated_at listo -->

<!-- [ ] Tabla tire_variants (opcional) listo -->
<!-- [ ] id (uuid) listo -->
<!-- [ ] tire_size_id (FK) listo -->
<!-- [ ] load_index (int, nullable) ej 91 listo -->
<!-- [ ] speed_index (varchar, nullable) ej "V" listo -->
<!-- [ ] UNIQUE(tire_size_id, load_index, speed_index) listo -->

<!-- [ ] Tabla search_logs (para futuro crecimiento) listo -->
<!-- [ ] id listo -->
<!-- [ ] query listo -->
<!-- [ ] query_type (code|size|unknown) listo -->
<!-- [ ] result_found (bool) listo -->
<!-- [ ] ip_hash (SHA-256 for GDPR) listo -->
<!-- [ ] created_at listo -->
<!-- [ ] Analytics endpoints (overview, top-searches) listo -->
<!-- [ ] Integración en LookupService listo -->

Índices/constraints imprescindibles:
<!-- [ ] UNIQUE(size_normalized) listo -->
<!-- [ ] UNIQUE(code_public) listo -->
<!-- [ ] UNIQUE(tire_size_id) en tire_codes listo -->
<!-- [ ] Índice en tire_variants por (tire_size_id, load_index, speed_index) listo -->
<!-- [ ] Migraciones (Prisma o TypeORM, pero con migrations sí o sí) listo -->
<!-- [ ] Seeds iniciales (50–200 filas) para pruebas listo -->

Normalizador (esto te hace “backend de nivel”)
<!-- [ ] Implementar normalización de medida: listo -->
<!-- [ ] quitar espacios listo -->
<!-- [ ] mayúsculas en “R” listo -->
<!-- [ ] aceptar entradas como “205/55 r16”, “205/55R 16”, “205 / 55 R16” listo -->
<!-- [ ] devolver siempre “205/55R16” listo -->
<!-- [ ] Parser opcional de LI/SI: listo -->
<!-- [ ] “91V” → load_index=91, speed_index=V listo -->
<!-- [ ] Tests unitarios del normalizador (varios casos raros) listo -->

API pública (primero lo que da valor)
<!-- [ ] GET /api/v1/lookup?code=100 listo -->
<!-- [ ] si existe → { code: “100”, size: “205/55R16”, variant?: { li, si } } listo -->
<!-- [ ] si no → 404 consistente listo -->

<!-- [ ] GET /api/v1/lookup?size=205/55R16 listo -->
<!-- [ ] devuelve { size, code } listo -->

<!-- [ ] Soporte opcional de LI/SI: listo -->
<!-- [ ] GET /api/v1/lookup?code=8&li=91&si=V listo -->
<!-- [ ] GET /api/v1/lookup?size=205/55R16&li=91&si=V listo -->
<!-- [ ] si la variant no existe → devuelve base y un aviso tipo “variant_not_found” listo -->

<!-- [ ] (Opcional UX) GET /api/v1/suggestions?query=205 listo -->
<!-- [ ] devuelve top medidas/códigos por prefijo listo -->

<!-- [ ] Swagger completo desde el día 1 (con ejemplos) listo -->
<!-- [ ] Rate limiting en endpoints públicos (muy importante) listo -->
<!-- [ ] Logs con requestId listo -->

Frontend mínimo (para que el proyecto sea demostrable)
[ ] Next.js página única:
[ ] input único que acepta “100” o “205/55R16” o “205/55R16 91V”
[ ] detecta tipo (número vs medida)
[ ] llama /lookup
[ ] muestra resultado limpio + botón copiar
[ ] mensajes humanos (no “stack traces”)
[ ] Página “Qué es TireCode” (explicación corta)
[ ] SEO básico

Admin (manual primero, porque te acelera)
[ ] Crear admin auth (JWT)
[ ] Rol admin
[ ] Endpoints:
<!-- [ ] POST /api/v1/admin/mappings listo -->
<!-- [ ] PATCH /api/v1/admin/mappings/:id listo -->
<!-- [ ] DELETE /api/v1/admin/mappings/:id (soft delete opcional) listo -->
[ ] POST /api/v1/admin/variants (crear variant 91V para una medida)
[ ] Auditoría mínima (quién creó/editó)
[ ] Validaciones fuertes + errores consistentes

Redis cache (para ser rápido y escalable ya desde v1)
<!-- [ ] Cache lookup por code_public listo -->
<!-- [ ] Cache lookup por size_normalized listo -->
<!-- [ ] TTL (ej 1h) + invalidación exacta al cambiar mapping: listo -->
<!-- [ ] al editar mapping → borrar cache de ese code y size listo -->
[ ] Medir latencia con y sin cache (aunque sea simple)

Import CSV + BullMQ (para meter “todos los neumáticos”)
Primero: entender CSV:
– Es un archivo exportado de Excel con columnas.

[ ] Endpoint admin: POST /api/v1/admin/import (sube CSV) listo
[ ] Guardar archivo temporal o en storage
<!-- [ ] Encolar job BullMQ “importMappings” listo -->
<!-- [ ] Job: listo -->
<!-- [ ] parsea filas listo -->
<!-- [ ] normaliza size listo -->
[ ] upsert (crear si no existe, actualizar si existe)
[ ] idempotencia (mismo CSV no crea duplicados)
<!-- [ ] retries + backoff listo -->
[ ] Reporte del import:
[ ] cuántos OK
[ ] cuántos duplicados
[ ] cuántos fallos y por qué

Testing completo (lo que te hace “muy buscado”)
Unit tests:
[ ] normalizador de tamaño
[ ] parser de LI/SI
[ ] regla 1:1 (no duplicados)

Integration tests:
[ ] lookup por code (200/404)
[ ] lookup por size (200/404)
[ ] admin create mapping (unique)
[ ] import CSV (upsert correcto)
[ ] Testcontainers con Postgres real (si puedes, esto suma muchísimo)

Objetivo:
[ ] cobertura base 60–70% en módulos core

Observabilidad (producción real)
[ ] /health
[ ] logs estructurados (pino o winston)
[ ] métricas básicas (opcional /metrics)
[ ] trazabilidad: requestId en logs y respuestas
[ ] alertas mínimas (cuando esté en cloud)

CI/CD + despliegue (portfolio serio)
[ ] GitHub Actions:
[ ] lint
[ ] test
[ ] build
[ ] docker build
[ ] Deploy staging automático
[ ] Deploy producción con aprobación manual
[ ] Migraciones controladas en deploy
[ ] Secrets fuera del repo
[ ] Rollback plan (volver a imagen anterior)

Preparación para futuro (sin construir microservicios aún)
[ ] Documentar (1–2 páginas):
[ ] roles futuros: workshop/manufacturer
[ ] diseño de “tire_instances” (cuando haya QR por neumático individual)
[ ] estrategia de escalado:
– Monolito modular ahora
– Extraer search-service si tráfico explota
– Extraer import-service si import crece
[ ] Añadir search_logs + anti-abuso (rate limit más agresivo)
[ ] Suggestions mejoradas si hace falta (prefijo + ranking)

Entrega final (para ser “contratable fuerte”)
[ ] Repo público con README impecable
[ ] Demo en cloud funcionando
[ ] Dataset cargado (mínimo 200)
[ ] Diagrama simple (API + Postgres + Redis + BullMQ)
[ ] Video corto mostrando:
[ ] buscar por “100”
[ ] buscar por “205/55R16”
[ ] admin crea mapping
[ ] import CSV


